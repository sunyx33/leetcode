# 数组

## 704. 二分查找 [easy]

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

**思路：**

二分查找看似简单，但边界问题需要注意，写不好很容易有bug。

我们定义middel指针在一个左闭右闭的区间中：[start, end]，左右边界都能取到，那么end = 真实下标（size - 1），且while (end >= start)，可以出现左右边界重合的情况。

另外，在更新start或end的时候，考虑到middel已经不是target了，则 start = middel + 1 或 end = middel - 1，不然会陷入死循环。

这种基础算法还是直接背过为好。

**代码：**

```c++
/*
 * @lc app=leetcode.cn id=704 lang=cpp
 *
 * [704] 二分查找
 */

// @lc code=start
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int start = 0;
        int end = nums.size() - 1;
        while (end >= start) {
            int middle = start + (end - start) / 2;
            if (target > nums[middle]) {
                start = middle + 1;
            } else if (target < nums[middle]) {
                end = middle - 1;
            } else {
                return middle;
            }
        }

        return -1;
    }
};
// @lc code=end
```



## 27. 移除元素 [easy]

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

**思路：**

暴力解法，两层循环，第一遍找到待删除的元素，第二遍将后面的元素集体后移一位，时间复杂度O(n^2)

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/27.移除元素-暴力解法.gif)

那么如何将两层循环优化为一层呢？用两个指针，都从头开始往后找，并在每次循环用快指针覆写慢指针，若快指针指到待删元素，就跳过覆写操作，自己往后移一个，继续下次循环。这样一来，一旦出现快慢差，就会将待删除指针覆写掉了（遇到几个待删除元素，快慢差就差几）。这样一层for搞定，O(n)

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/27.移除元素-双指针法.gif)

**代码：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```



## 977. 有序数组的平方 [easy]

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

**思路：**

数组其实是有序的， 只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

给两个指针，两边往中间靠，每次从两个指针指的数选择一个绝对值大的倒序填入新数组。

**代码：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k = nums.size() - 1;
        vector<int> result(nums.size(), 0);
        for (int i = 0, j = nums.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (nums[i] * nums[i] < nums[j] * nums[j])  {
                result[k--] = nums[j] * nums[j];
                j--;
            }
            else {
                result[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return result;
    }
};
```



## 209. 长度最小的子数组 [medium]

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)

**思路：**

滑动窗口思想——**不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

暴力解法中两个for循环其实就表示了窗口的首尾，但其中有很多冗余的操作。那么用一个for循环，循环量是窗口尾部，每次满足条件，头部再+1，找新的尾部就好。

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/209.长度最小的子数组.gif)

**代码：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int result = __INT32_MAX__;
        int start = 0;
        int sum = 0;
        int sublenth = 0;
        for (int end = 0; end < nums.size(); end++) {
            sum += nums[end];
            while(sum >= target) {
                sublenth =  end - start + 1;
                result = result < sublenth ? result : sublenth;
                sum -= nums[start++];
            }
        }
        return result == __INT32_MAX__ ? 0 : result;
    }
};
```



## 59. 螺旋矩阵 [medium]

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

**思路：**

按条件往下写，注意边界问题。

在写复杂循环时，一定要注意做到：所有的循环条件都按照一个标准（如都是左闭右开区间），即**循环不变量原则**。

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/20220922102236.png)

**代码：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```





# 链表

## 203. 移除链表元素 [easy]

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

**思路：**

链表删除节点的基础操作，没啥好说的。注意两点：

* 头节点的删除，要么来一个虚拟头节点指向头节点，删除逻辑与其他一样；要么就写一段单独的逻辑：头节点向后移一步，释放头节点。
* c++在删除时，注意用delete释放堆区内存（new过的）。

**代码：**

```c++
/*
 * @lc app=leetcode.cn id=203 lang=cpp
 *
 * [203] 移除链表元素
 */
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0, head);
        ListNode* cur = dummyHead;
        while (cur->next) {
            if (cur->next->val == val){
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
// @lc code=end
```



## 707. 设计链表 [medium]

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)

**思路：**

本题为实现链表的一些基本操作，不难，这里主要规范一下链表的数据结构：

```c++
class MyLinkedList {
public:
    struct Node{
        int val;
        Node* next;
        Node(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new Node(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }
    
    //各种方法...
        
private:
    Node* _dummyHead;
    int _size;
}
```



**代码：**

```c++
/*
 * @lc app=leetcode.cn id=707 lang=cpp
 *
 * [707] 设计链表
 */

// @lc code=start
class MyLinkedList {
public:
    struct Node{
        int val;
        Node* next;
        Node(int val):val(val), next(nullptr){}
    };
    
    // 初始化链表
    MyLinkedList() {
        _dummyHead = new Node(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
           return -1; 
        }
        Node* cur = _dummyHead->next;

        while (index --) {
            cur = cur->next;
        }

        return cur->val;
    }
    
    void addAtHead(int val) {
        Node* newNode = new Node(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size ++;
    }
    
    void addAtTail(int val) {
        Node* newNode = new Node(val);
        Node* cur = _dummyHead;
        while(cur->next != nullptr) {
            cur = cur->next;
        }
        cur->next = newNode;
        _size ++;

    }
    
    void addAtIndex(int index, int val) {
        if(index > _size){
            return;
        } else if (index <= 0) {
            addAtHead(val);
        } else {
            Node* newNode = new Node(val);
            Node* cur = _dummyHead;
            while (index --) {
                cur = cur->next;
            }
            newNode->next = cur->next;
            cur->next = newNode;
            _size ++;
        }
        

    }
    
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        } 
        Node* cur = _dummyHead;
        while(index --){
            cur = cur->next;
        }
        Node* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size --;
    }

private:
    Node* _dummyHead;
    int _size;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
// @lc code=end
```



## 206. 翻转链表 [easy]

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

**思路：**

从头节点的前一个结点开始，记录前中后三个节点，中指向前，中等于后，前等于中，后等于后+1.

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/206.翻转链表.gif)

**代码：**

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// @lc code=start
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp;
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            temp = cur->next;
            cur->next = pre;
        
            pre = cur;
            cur = temp;        
        }
        return pre;   
    }
};
// @lc code=end
```



## 24. 两两交换链表中的节点 [medium]

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)

**思路：**

首先是要设置虚拟头节点，目的是让真头节点一般化

交换位置，从小到大，从左向右依次交换。先画图模拟，交换过程中没有指针指向的节点就要用tmp先存起来。

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/24.两两交换链表中的节点1.png)

比如步骤一，1失去指向它的指针；步骤二，3失去指向它的指针。

另外，注意判空指针，很重要。

**代码：**

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next; // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;    // 步骤一
            cur->next->next = tmp;          // 步骤二
            cur->next->next->next = tmp1;   // 步骤三

            cur = cur->next->next; // cur移动两位，准备下一轮交换
        }
        return dummyHead->next;
    }
};
```



## 19. 删除链表的倒数第N个节点 [medium]

**思路：**

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

**代码：**

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
// @lc code=start
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        while(n-- && fast != NULL) {
            fast = fast->next;
        }
        if (fast != NULL){
            fast = fast->next;
        }
     
        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;   
        
        return dummyHead->next;
    }
};
// @lc code=end
```

## 160. 相交链表 [easy]

[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

**思路：**

- 计算两个链表的长度差gap
- 相交点在后面，所以从前面的同一起点开始（长链表先向前走gap步），一起往后逐个比较。

**代码：**

```c++
#include <stdio.h>
#include <algorithm>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
 };
 
// @lc code=start
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = 0;
        int lenB = 0;
        ListNode *curA = headA;
        ListNode *curB = headB;

        // 求A长度
        while(curA != NULL){
            lenA ++;
            curA = curA->next;
        }

        // 求B长度
        while(curB != NULL){
            lenB ++;
            curB = curB->next;
        }

        // 返回头节点
        curA = headA;
        curB = headB;

        // 保持curA是长链表的节点
        if (lenB > lenA) {
            swap(curA, curB);
            swap(lenA, lenB);
        }

        int gap = lenA - lenB;

        // curA走到curB的起点
        while(gap--){
            curA = curA->next;
        }

        while(curA != NULL){
            if(curA == curB){
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }

        return NULL;

    }
};
// @lc code=end
```

## 142. 环形链表Ⅱ [medium]

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

**思路：**

[牛逼，建议全文背诵](https://www.programmercarl.com/0142.环形链表II.html#_142-环形链表ii)

首先，怎么确定一个链表是否有环？

定义快慢两个指针，快指针一次走两步，慢指针一次走一步，快指针先走，那么如果两指针相遇，则一定有环。很简单，跑的快的人比跑的慢的人先跑，如果后面两人相遇了，那就是套圈了呗。

其次，如何确定环的入口？

假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/20220925103433.png)

观察相遇时刻，慢指针走了 x + y 个节点，快指针走了 x + n ( y + z ) + y个节点，两者相遇，所用时间相等，则快指针走的节点数是慢指针的两倍。故有：

$$
2(x+y) = x + y+n(y+z)
$$

化简得：

$$
x -z= (n - 1) (y + z)
$$

由此可得，x与z的节点数差就是整数倍的圈长。（注意，此处 n ≥ 1）

那么我们让另外两个同速指针从**头节点**与**相遇节点**同时出发，每次走一步，那么两指针相遇处就一定是环形入口了。

> 为啥人家就那么聪明呢？

**代码：**

```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
// @lc code=start

class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while (1)
        {
            if (fast != NULL && fast->next != NULL && fast->next->next != NULL){
                fast = fast->next->next;
                slow = slow->next;
                if(fast == slow){
                    break;
                }
            } else {
                return NULL;
            }

        }

        slow = head;

        while (1)
        {
            if(fast == slow) {
                return fast;
            }
            fast = fast->next;
            slow = slow->next;
        }

        return NULL;    
    }
};
// @lc code=end
```





# 哈希表

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map(映射)

这里数组就没啥可说的了，我们来看一下set。

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

关于set的基础知识：

[C++ STL set容器完全攻略（超级详细） (biancheng.net)](http://c.biancheng.net/view/7192.html)

[C++ STL unordered_set容器完全攻略 (biancheng.net)](http://c.biancheng.net/view/7250.html)

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？

实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/20210104235134572.png)

总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

## 242. 有效的字母异位词 [easy]

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)

**思路：**

遍历两个字符串，统计每个字母出现的顺序，用一个数组记录。（数组的索引为该字母的ASCII值，这也就是哈希方法的体现）

**代码思路：**

1. 建立一个长度为26的数组 `count`，用于记录每个字母的出现频次。（f  =>>  count['f'-'a']; ）
2. 遍历第一个字符串，++记录
3. 遍历第二个字符串，--记录
4. 检查 `count`数组是否全部为0（遍历），是返回true，否返回false。

**代码：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int count[26] = {0};
        for (int i = 0; i < s.size(); i++)
        {
            count[s[i]-'a'] ++;
        }
        for (int j = 0; j < t.size(); j++)
        {
            count[t[j]-'a']--;
        }
        for (int k = 0; k < 26; k++)
        {
            if (count[k] != 0)
            {
                return false;
            }
        }
        return true;
    }
};
```



## 349. 两个数组的交集 [easy]

[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)

**思路：**

将nums1转换为哈希表的形式（具体用set来实现），然后遍历查找nums2的数字是否存在于哈希表中，若存在则记录为最终结果。

**代码思路：**

1. 定义一个 `unordered_set` 作为存放结果的地方（顺带去重效果）
2. 将 `nums1`转为 `unordered_set`
3. 将 `nums2` 与上一步的结果进行比对，比对上的录入最终结果

**代码：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果
        unordered_set<int> nums_set(nums1.begin(), nums1.end()); // 使用迭代器进行初始化，vec -> set
        for(int num : nums2){
            if(nums_set.find(num) != nums_set.end()){
                result_set.insert(num);
            }
        }

        return vector<int>(result_set.begin(), result_set.end());
    }
};
```



## 202. 快乐数 [easy]

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)

**思路：**

本质上还是要老老实实递归往下算，重点在于如何判断是否陷入无限循环：即判断是否算出了先前出现的结果。这里本质是一个查找操作，自然想到哈希方法，用一个 `unordered_set` 来存储出现过的所有结果，以便进行比对。

**代码思路：**

1. 首先要写一个各位平方和的方法，通过除以10取余的方式来提取出各位。
2. 正常计算，算完后判断一下是否为1，是的话返回true
3. 若不为1，则将结果与存放结果的set进行比对，若比对上则返回false，表示已经开始循环；若没有比对上则录入结果，继续算。

**代码：**

```c++
class Solution {
public:
    int getSum(int n){
        int sum = 0;
        while (n) {
            sum += (n % 10 ) * (n % 10);
            n /= 10;
        }

        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> res;
        while (1) {
            n = getSum(n);
            if (n == 1) {
                return true;
            }

            if (res.find(n) != res.end()){
                return false;
            } else {
                res.insert(n);
            }
        }    
    }
};
```



## 1. 两数之和 [easy]

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)

**思路：**

在给定数据中查找是否有target - nums[i]这个数字，如果有则返回i和这个数字的下标。查找一个集合中是否有某个元素，就应该想到哈希方法。这里我们可以用 `unordered_map` 这一结构，key为数字的值，value为数字的下标，这样知道要找的数字的值，就可以快速锁定其在原数组的下标。

**代码思路：**

1. 首先要把给定数据转成 `unordered_map` ，但不是一次性转完，+而是一边找一边转（如下）
2. 遍历数组，寻找当前map中是否有target-nums[i]这个数字，如果有，则返回i与map中该key所对应的value。
3. 若没有，则将 `key = nums[i],  value = i` 插入map中，继续下次循环。

**代码：**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> res;
        for(int i = 0; i < nums.size(); i++){
            auto iter = res.find(target - nums[i]);
            if(iter != res.end()){
                return {iter->second, i};
            }
            res.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```



## 454. 四数相加 [medium]

[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/)

**思路：**

与上题类似。记录AB数组所有和的情况（这里仅记录不同结果出现的次数）（map，key=和，value=次数），然后遍历CD数组所有和的情况，查看map中是否有0-C[i]-D[i]的key，有的话结果+1.

**代码思路：**

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

**代码：**

```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```



## 383. 赎金信 [easy]

[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)

**思路：**

与242题十分相似，用数组对每个字母计数，然后遍历赎金信减去数组相应字母的数量，看是否有负数。

**代码思路：**

1. 若ran.size() > mag.size()，直接返回false
2. 遍历mag计数
3. 遍历ran反向计数

**代码：**

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        if(ransomNote.size() > magazine.size()){
            return false;
        }

        for(int i = 0; i < magazine.size(); i++){
            record[magazine[i] - 'a'] ++;
        }

        for(int j = 0; j < ransomNote.size(); j++){
            record[ransomNote[j] - 'a'] --;
            if(record[ransomNote[j] - 'a'] < 0){
                return false;
            }
        }

        return true;
    }
};
```





# 字符串

## 344. 反转字符串 [easy]

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)

**思路：**

为数不多我可以重拳出击的题，没啥好说的，头尾俩指针，swap，往中间走。

**代码：**

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0;
        int right = s.size() - 1;
        while(right > left){
            swap(s[left], s[right]);
            left ++;
            right --;
        }
    }

    void swap(char& a, char& b){
        char temp = a;
        a = b;
        b = temp;
    }
};
```



## 541. 反转字符串II

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)

**思路：**

这是一个找规律模拟题，每次需要反转的字串都可以写成关于k的函数：start = (i - 1) * k；end = i * k - 1；其中i = 1,3,5,7,...

 (i - 1) * k ~  i * k - 1这个窗口没有发生越界的话，就对这个子串反转，否则对从 i * k - 1到头的所有字符反转。

至于反转字符串就无需多言了。

**代码：**

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 1; (i - 1) * k < s.size(); i = i + 2 ) {
            if ((i * k - 1) < s.size()) {
                reverse(s, (i - 1) * k, i * k - 1);
            } else {
                reverse(s, (i - 1) * k, s.size() - 1);
            }
        }

        return s;
    }

    void reverse(string& s, int start, int end){
        while(start < end){
            swap(s[start], s[end]);
            start ++;
            end --;
        }
    }
};
```



## 剑指Offer | 05. 替换空格 [easy]

[剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

**思路：**

空格变成"%20"，字符串变长了，要扩容。

**很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

所以，先统计空格个数，计算扩容后长度，进行扩容。接着，从后往前，双指针，速差来源于空格，一个空格三个速差。

**代码：**

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0; // 统计空格的个数
        int sOldSize = s.size();
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                count++;
            }
        }
        // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小
        s.resize(s.size() + count * 2);
        int sNewSize = s.size();
        // 从后先前将空格替换为"%20"
        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
            if (s[j] != ' ') {
                s[i] = s[j];
            } else {
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;
    }
};
```



## 151. 翻转字符串里的单词 [medium]

[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)

**思路：**

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

移除前后多余空格比较难，自带的erase方法时间复杂度是O(n)，他在for循环里，就成了O(n^2)，所以不能用。

使用双指针法来去移除空格，最后resize（重新设置）一下字符串的大小，就可以做到O(n)的时间复杂度。思路同移除元素，但这里要保留单词间的空格。具体代码如下：

**代码：**

移除多余空格：

```c++
void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
    int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
    for (int i = 0; i < s.size(); ++i) { //
        if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
            if (slow != 0) s[slow++] = ' '; //slow != 0说明不是第一个单词，需要在单词前添加空格。
            while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                s[slow++] = s[i++];
            }
        }
    }
    s.resize(slow); //slow的大小即为去除多余空格后的大小。
}
```

整体：

```c++
class Solution {
public:
    string reverseWords(string s) {
        delEmpty(s);
        reverse(s, 0, s.size() - 1);
        for (int i = 0; i < s.size(); i++){
            int start = i;
            while(i < s.size() && s[i] != ' ') {
                i ++;
            }
            reverse(s, start, i - 1);
        }
        return s;
    }

    void reverse(string& s, int start, int end){
        while(start < end){
            swap(s[start], s[end]);
            start ++;
            end --;
        }
    }

    void swap(char& a, char& b){
        char temp = a;
        a = b;
        b = temp;
    }

    void delEmpty(string& s){
        int slow = 0;
        for (int fast = 0; fast < s.size(); fast++) {
            if (s[fast] != ' ') {
                if (slow != 0) s[slow++] = ' ';
                while (fast < s.size() && s[fast] != ' ') { 
                    s[slow++] = s[fast++];
                }
            }
        }
    
        s.resize(slow);
    }
};
```



## 剑指Offer | 58-II.左旋转字符串 [easy]

[剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

**思路：**

第一种，要用到额外空间，将字符延长至size + n，其中size + i的位置放第i个字符，i=0,1,...,n

第二种，不用额外空间：

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/剑指Offer58-II.左旋转字符串.png)

两种差不多，第二种相较于第一种少了空间，多了时间。

**代码：**

第一种：

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        int size = s.size();
        s.resize(size + n);
        for(int i = 0; i < n ; i++) {
            s[size + i] = s[i];
        }
        return s.substr(n);
    }
};
```

第二种：

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin() + n);
        reverse(s.begin() + n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```





# 双指针法

## 15. 三数之和 [medium]

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

**思路：**

两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，其实这个思路是正确的，时间复杂度也更低（o(n^2)），但在结果去重时非常困难，故采用双指针法来做。

双指针法的大前提是，该数列是一个从小到大排序后的数列。我们选择一个起始位置i，另外有两个指针：left = i + 1， right = nums.size() - 1，每次找答案时，i固定，判断三个指针指向数字之和，若大于0，right左移；若小于0，left右移；等于0，记录结果。具体效果可以看下图：

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/15.三数之和.gif)

再说去重思路。对于a的去重，判断当前位置与前一个是否相等，若相等，则cotinue（因为最小数为这个数的所有情况已然穷尽）。对于b、c的去重，则是当找到一组解后，若发现right的左边或left右边与当前数字相等，则继续左移或右移。

**代码：**

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());

        for(int i = 0; i < nums.size(); i++){
            // 从小到大排序，第一个都大于0则不可能和为0
            if(nums[i] > 0){
                return result;
            }

            int left = i + 1;
            int right = nums.size() - 1;

            // 对i进行去重
            if(i > 0 && nums[i] == nums[i-1]){
                continue;
            } 

            // 进行left与right的移动
            while (right > left) { 
                if(nums[i] + nums[left] + nums[right] > 0){
                    right --;
                } else if (nums[i] + nums[left] + nums[right] < 0)
                {
                    left ++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            
            }
        
        }
        return result;
    }
};
```



## 18. 四数之和 [medium]

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

**思路：**

同三数和一样，仅仅加了一个for循环（i， i+1 -> end, left & right -> mid）

**代码：**

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 剪枝处理
            if (nums[k] > target && nums[k] >= 0) {
            	break; // 这里使用break，统一通过最后的return返回
            }
            // 对nums[k]去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 2级剪枝处理
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }

                // 对nums[i]去重
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                    } else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 对nums[left]和nums[right]去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }
};
```





之前做过的题：

数组：

[27.移除元素 [easy]](#27. 移除元素 [easy])

链表：

[206.翻转链表 [easy]](#206.翻转链表 [easy])

[19.删除链表的倒数第N个节点 [medium]](#19.删除链表的倒数第N个节点 [medium])

[160.相交链表 [easy]](#160.相交链表 [easy])

[142.环形链表Ⅱ [medium]](#142.环形链表Ⅱ [medium])

字符串：

[344.反转字符串 [easy]](#344.反转字符串 [easy])

[剑指Offer | 05. 替换空格 [easy]](#剑指Offer | 05. 替换空格 [easy])

[151. 翻转字符串里的单词 [medium]](#151. 翻转字符串里的单词 [medium])



## 总结

什么时候用双指针呢？

首先，用双指针的最底层思想就是用两个指针来避免嵌套的两层循环，一次循环中指两个位置。

可以首尾相向走，做反转等操作。也可以用快慢指针，用速差去做一些事情。如删除，慢指针指向待删除，快指针找到后面不删除的元素，进行覆写；或者用速差去找链表的环，环的入口。





# 其他

## 13. 罗马数字转整数 [easy]

[13. 罗马数字转整数 - 力扣（LeetCode）](https://leetcode.cn/problems/roman-to-integer/)

**思路：**

从左往右查看字符串，每次看一个字符并与后面的字符比较，从而算出数值。

**代码思路：**

1. 首先建立罗马字母与整数的映射表（可以是hash表，也可以是case语句）
2. 从左到右遍历遍历字符串，取得当前位置与下一个位置的数值
3. 比较两个数值，确定是+还是-
4. 倒数第二个字符看完后，跳出循环，最后一个肯定是+

**代码：**

```java
class Solution {
	public int romanToInt(String s) {
		int result = 0;
		int preNum = getValue(s.charAt(0));

		for(int i = 1; i < s.length(); i++){
			int num = getValue(s.charAt(i));
        
			if(preNum < num){
				result -= preNum;
			}
			else{
				result += preNum;
			}
        
			preNum = num;
		}

		result += preNum;
		return result;

	}

	private int getValue(char ch){
		switch (ch){
			case 'I' : return 1;
			case 'V' : return 5;
			case 'X' : return 10;
			case 'L' : return 50;
			case 'C' : return 100;
			case 'D' : return 500;
			case 'M' : return 1000;
			default : return 0;
		}
	}
}
```

然后看到一个很秀的答案，贴一下：

```java
class Solution {
    public int romanToInt(String s) {
        s = s.replace("IV","a");
        s = s.replace("IX","b");
        s = s.replace("XL","c");
        s = s.replace("XC","d");
        s = s.replace("CD","e");
        s = s.replace("CM","f");
    
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            res += getValue(s.charAt(i));
        }
        return res;
    }

    public int getValue(char c) {
        switch(c) {
            case 'I': return 1;
            case 'V': return 5;
            case 'X': return 10;
            case 'L': return 50;
            case 'C': return 100;
            case 'D': return 500;
            case 'M': return 1000;
            case 'a': return 4;
            case 'b': return 9;
            case 'c': return 40;
            case 'd': return 90;
            case 'e': return 400;
            case 'f': return 900;
        }
        return 0;
    }
}
```

别问，问就是打表！



## 14. 最长公共前缀 [easy]

[14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/)

**思路：**

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/14_fig2.png)

**代码思路：**

1. 以第一个单词为模板，遍历其中字母
2. 在遍历中嵌套遍历，比较剩下所有单词的相应位置字母是否与之相同（或是单词在该位置无字母）
3. 如遇到不相同的或到头的，则停止，记录当前遍历的位置，输出第一个单词到这个字母的字串即可。

**代码：**

```java
class Solution {
	public String longestCommonPrefix(String[] strs) {
		// 若其中无字符
		if (strs == null || strs.length == 0) {
			return "";
		}

		int length = strs[0].length();
		int count = strs.length;

		// 遍历第一个str的每个字母
		for(int i = 0; i < length; i++){
			char c = strs[0].charAt(i);

			// 比较后面每个strs的相应位字母
			for(int j = 1; j < count; j++){
				// 若比到该字符串的末尾（前面相同才会向后移动）或比到了不相同的字符
				if(i == strs[j].length() || strs[j].charAt(i) != c){
					return strs[0].substring(0, i);
				}
			}
		}

		return strs[0];

	}
}
```



## 9. 回文数 [easy]

[9. 回文数 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-number/)

**思路：**

可以转换为字符串，用两个指针分别从两头开始比较。也可以借用栈的思想，开两个栈，比较栈顶元素（奇数位需去掉中间那个数字）。但还有一个更巧妙的方法就是直接求这个数字的倒序数，判断与原数是否相等即可。

**代码思路：**

1. 求目标的倒序数（求法见代）
2. 判断输出

（这很优雅😍）

**代码：**

```java
class Solution {
    public boolean isPalindrome(int x) {
		if(x < 0){
			return false;
		}
		int reversedNum = 0;
		int tempNum = x;
		while(tempNum != 0){
            // 这里是求倒序数，利用除以10取余得到原数最后一位，若最后一位为0则停止，这样也兼顾了诸如1200这样的情况。
			reversedNum = reversedNum * 10 + tempNum % 10;
			tempNum = tempNum / 10;
		}

		if(reversedNum == x){
			return true;
		}

		else{
			return false;
		}
	}
}
```



## 7. 求反转数 [medium]

[7. 整数反转 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-integer/)

第一道中等题，可喜可贺。

其实思路和上道一样的，看着差不多就做了，结果发现难点是在于那个溢出的判断。

**思路：**

求反转数思路看上题。至于如何判断溢出——

![](https://sunnyx-1306524139.cos.ap-chengdu.myqcloud.com/img/image-20220902182358609.png)

还是牛的，我没想到。

**代码思路：**

上道的基础上加一个判断，详见代码，此处略。

**代码：**

```java
class Solution {
    public int reverse(int x) {
        // 这里不涉及到与原数比较，就不用保留x了
		int reversedNum = 0;
    
		while(x != 0){
			int tempNum = x % 10;

			if(reversedNum > 214748364 || (reversedNum == 214748364 && tempNum > 7)) {
				return 0;
			}

			if(reversedNum < -214748364  || (reversedNum == -214748364 && tempNum < -8)) {
				return 0;
			}

			reversedNum = reversedNum * 10 + tempNum;
			x /= 10;
		}

		return reversedNum;
    }
}
```
